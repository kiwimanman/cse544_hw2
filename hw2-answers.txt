Keith Stone
CSE 544 Winter 2014

2. B.

The various properties for the insured relationship between Vehicle and Insurance Co live in the Vehicle table.
This is due to the one to many counting. The foreign key lives here in the property called insured_by.
The other two properties, maxLossDamage and maxLiability, both also live on vehicle due to being one to one with the
foreign key insured_by.

2. C. 

Operates is a one-to-many relationship between Truck and nonProfessionalDriver. The foreign key lives on the truck
as the operated_by property in the schema.

Drives is a many-to-many relationship and requires a seperate table to model correctly in the schema. This table is
called Cars_nonProfessionalDrivers and contains an id field as a primary key and two attributes licencePlate and licenceNo
which are foreign key for the Car(licencePlate) and nonProfessionalDriver(licenceNo) respectively.

3. i.

R(A,B,C,D,E)

Decompose R using D -> B, Results in:

R'(A,C,D,E), A(D,B)

Decompoase R' using CE => A, Results in:

R''(C,D,E), A(D,B), B(C,E,A)

All remaining dependencies are trivial making this BCNF. This fixes anomalies that could show up between the columns B and A.

3. ii.

S(A,B,C,D,E)

(B,D,E), (A,C,D,E)

(A,C,D) (A, E)

Compute X+ for all X:

A+ = AE, B+ = B, C+ = C, D+ = D, E+ = E
AB = ABE, AC+ = ACE, AD+ = ADE, AE+ = AE
BC+ = ABCE, BD+ = BD, BE+ = BE
CD+ = CD, CE+ = CE
DE+ = BDE
ABC+ = ABCE, ABD+ = ABDE, ABE+ = ABE
ACD+ = ACDE, ACE+ = ACE, ADE+ = ABDE
BCD+ = BCD, BCE+ = 


4. A.

There are no functional dependencies.

4. B.

A -> B,
B -> C,
C -> D,
D -> A

4.C.

A -> B,
B -> A,
C -> AD,
D -> AC



select month, count(distinct discount) from sales group by month;

 month | count 
-------+-------
 apr   |     1
 aug   |     1
 dec   |     1
 feb   |     1
 jan   |     1
 jul   |     1
 jun   |     1
 mar   |     1
 may   |     1
 nov   |     1
 oct   |     1
 sep   |     1
(12 rows)

month => discount

select * from (
  select name, count(distinct price)
  from sales
  group by name
) as functional_check
where functional_check.count > 1;

 name | count 
------+-------
(0 rows)

name => price


